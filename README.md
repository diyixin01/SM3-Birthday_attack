# SM3-Birthday_attack
利用生日攻击找n比特碰撞的原像
​ 对于任意消息（这里只考虑数字字符串，其他字符串也可以转化到数字字符串）M，我们计算H=SM3(M)，如果我们只考虑前n比特（下文中的相等都是指前n比特），那么在前0-2^n范围内，至少存在一组碰撞的概率几乎是100%。

​ 那么对于特定的消息M，如何利用生日攻击去找到这个碰撞像呢？

​ 我们可以任取两个消息m1，m2，计算h=SM3(abs(M1-M2)，直到得到H= h


# 误差分析

假设存在M‘，有SM3(M)=SM3(M')，那么我们在前2^n比特范围内找到M'的概率是1/2^n,但是我们找两个数m1和m2，满足m1-m2 = M’的概率则是（C2n，2）/2^n,这个比较类似素数检测中的Poll_rho算法。
利用生日攻击找到任意一组前n比特的碰撞
​ 如果我们不是利用生日攻击去找碰撞像，而是单纯找两个消息m1和m2满足SM3(m1)=SM3(m2)，那么最简单的肯定还是穷举，使用hash表，遇到碰撞就输出。

代码运行如下图所示



![image](https://user-images.githubusercontent.com/75195549/179918529-c44d32d9-4970-40cf-917b-a114df111016.png)





发现第一行的一个碰撞是下面第二行，所用时间如图所示，当然我们也可以改变碰撞的比特数，比特数越少，碰撞越容易。
